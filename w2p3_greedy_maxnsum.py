

# найдите максимальное число k, для которого n можно 
# представить как сумму k различных натуральных слагаемых
# жадно, начинаем с единицы, если разность числа и очередного слагаемого 
# меньше его самого, значит оно не помеситится без повторения, пропускаем
def max_n_sum(n: int) -> tuple:
    n_copy = n
    k_num = []

    number = 1
    while True:  # O(n)
        if n_copy - number == 0:
            k_num.append(number)
            break
        elif n_copy - number <= number:
            number += 1
        else:
            n_copy -= number
            k_num.append(number)
            number += 1

    return len(k_num), k_num  # O(n)


if __name__ == "__main__":
    n = int(input())

    k, k_num = max_n_sum(n)

    print(k)
    print(*k_num)

# Другое, но тоже полезное решение.
# O(1). Я сжульничал, и решал не жадным алгоритмом.
# Максимальным разложением сумы S на слагаемые будет разложение на арифметическую прогрессию с 1 до N (с шагом 1), 
# плюс одно слагаемое L, если S нельзя представить сумой прогрессии:
# N * (N + 1) / 2 + L = S
# При этом L > N, иначе L повторит одно из уже использованых сложителей. Значит:
# N * (N + 1) / 2 + N < S
# N^2 + 3N - 2S < 0
# Решаем квадратное уравнение:
# N < (sqrt(8S + 9) - 3) / 2
# Значит максимальное значение N:
# N = ceil((sqrt(8S + 9) - 3) / 2 - 1) = ceil((sqrt(8S + 9) - 5) / 2)
# Теперь осталось только найти последнее слагаемое:
# L = S - N * (N + 1) / 2
# И вывести:
# Количество слагаемых: N + 1
# Слагаемые: [1; N], L